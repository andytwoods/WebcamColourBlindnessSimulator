<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam Colour Blindness Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
        }

        #canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
        }

        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body class="bg-gray-900">
<div id="canvas-container">
    <canvas id="canvas" class="w-full h-full"></canvas>
    <div class="controls">
        <label for="type" class="block text-white mb-2">Type:</label>
        <select id="type" class="block mb-4 p-2 rounded">
            <option value="0">Protanopia</option>
            <option value="1">Deuteranopia</option>
            <option value="2">Tritanopia</option>
        </select>
        <label for="correction" class="block text-white mb-2">Correction:</label>
        <input type="range" id="correction" min="0" max="1" step="0.01" value="1" class="block mb-4 w-full">
        <label for="camera" class="block text-white mb-2">Camera:</label>
        <select id="camera" class="block mb-4 p-2 rounded"></select>
        <label class="block text-white mb-2">
            <input type="checkbox" id="mirror" class="mr-2"> Mirror Image
        </label>
    </div>
</div>
<script>
    const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 vTexCoord;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
                vTexCoord = vec2(a_texCoord.x, 1.0 - a_texCoord.y);
            }
        `;

    const fragmentShaderSource = `
            precision mediump float;
            uniform sampler2D tex;
            uniform int colour_blindness_type;
            uniform float colour_blindness_correction;
            varying vec2 vTexCoord;

            void main(void) {
                vec4 color = texture2D(tex, vTexCoord);

                // RGB to LMS conversion
                mat3 RGB_to_LMS = mat3(
                    0.31399022, 0.63951294, 0.04649755,
                    0.15537241, 0.75789446, 0.08670142,
                    0.01775239, 0.10944209, 0.87256922
                );

                // LMS to RGB conversion
                mat3 LMS_to_RGB = mat3(
                    5.47221206, -4.6419601, 0.16963708,
                    -1.1252419, 2.29317094, -0.1678952,
                    0.02980165, -0.19318073, 1.16364789
                );

                // Transform the color from RGB to LMS
                vec3 LMS = RGB_to_LMS * color.rgb;

                vec3 simulated_LMS;
                if (colour_blindness_type == 0) {
                    // Protanopia simulation
                    simulated_LMS = vec3(
                        0.0,
                        LMS.g,
                        LMS.b
                    );
                } else if (colour_blindness_type == 1) {
                    // Deuteranopia simulation
                    simulated_LMS = vec3(
                        LMS.r,
                        0.0,
                        LMS.b
                    );
                } else if (colour_blindness_type == 2) {
                    // Tritanopia simulation
                    simulated_LMS = vec3(
                        LMS.r,
                        LMS.g,
                        0.0
                    );
                } else {
                    simulated_LMS = LMS;
                }

                // Adjust the simulation with the correction factor
                simulated_LMS = mix(LMS, simulated_LMS, colour_blindness_correction);

                // Transform the color back from LMS to RGB
                vec3 simulated_RGB = LMS_to_RGB * simulated_LMS;

                gl_FragColor = vec4(simulated_RGB, color.a);
            }
        `;

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,
        1, -1,
        -1, 1,
        -1, 1,
        1, -1,
        1, 1,
    ]), gl.STATIC_DRAW);

    const texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0, 0,
        1, 0,
        0, 1,
        0, 1,
        1, 0,
        1, 1,
    ]), gl.STATIC_DRAW);

    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

    let video = document.createElement('video');
    video.autoplay = true;
    let currentStream = null;

    async function setupVideo(deviceId) {
        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
        }
        const constraints = {
            video: {deviceId: deviceId ? {exact: deviceId} : undefined}
        };
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = currentStream;
        return video;
    }

    async function getCameras() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        const cameraSelect = document.getElementById('camera');
        cameraSelect.innerHTML = '';
        videoDevices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Camera ${cameraSelect.length + 1}`;
            cameraSelect.appendChild(option);
        });
    }

    function updateTexture() {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    }

    function drawScene() {
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(program);

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.enableVertexAttribArray(texCoordLocation);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

        updateTexture();

        const type = parseInt(document.getElementById('type').value);
        const correction = parseFloat(document.getElementById('correction').value);
        const mirror = document.getElementById('mirror').checked;

        gl.uniform1i(gl.getUniformLocation(program, 'tex'), 0);
        gl.uniform1i(gl.getUniformLocation(program, 'colour_blindness_type'), type);
        gl.uniform1f(gl.getUniformLocation(program, 'colour_blindness_correction'), correction);

        if (mirror) {
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                1, -1,
                -1, -1,
                1, 1,
                1, 1,
                -1, -1,
                -1, 1,
            ]), gl.STATIC_DRAW);
        } else {
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,
                1, -1,
                -1, 1,
                -1, 1,
                1, -1,
                1, 1,
            ]), gl.STATIC_DRAW);
        }

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(drawScene);
    }

    document.getElementById('camera').addEventListener('change', async (event) => {
        await setupVideo(event.target.value);
        video.play();
    });

    video.addEventListener('canplay', () => {
        video.play();
        requestAnimationFrame(drawScene);
    });

    getCameras();
    setupVideo();
</script>
</body>
</html>
