<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam Colour Blindness Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
        }

        #canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
        }

        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }

        .section-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 14px;
            z-index: 5;
        }
    </style>
</head>
<body class="bg-gray-900">
<div id="canvas-container">
    <canvas id="canvas" class="w-full h-full"></canvas>
    <div class="controls">
        <label for="type" class="block text-white mb-2">Type:</label>
        <select id="type" class="block mb-4 p-2 rounded">
            <option value="3" selected>Show All</option>
            <option value="0">Protanopia</option>
            <option value="1">Deuteranopia</option>
            <option value="2">Tritanopia</option>
        </select>
        <label for="correction" class="block text-white mb-2">Correction:</label>
        <input type="range" id="correction" min="0" max="1" step="0.01" value="1" class="block mb-4 w-full">
        <label for="camera" class="block text-white mb-2">Camera:</label>
        <select id="camera" class="block mb-4 p-2 rounded"></select>
        <label for="resolution" class="block text-white mb-2">Resolution:</label>
        <select id="resolution" class="block mb-4 p-2 rounded">
            <option value="640x480">640x480</option>
            <option value="1280x720" selected>1280x720 (HD)</option>
            <option value="1920x1080">1920x1080 (Full HD)</option>
        </select>
        <label class="block text-white mb-2">
            <input type="checkbox" id="mirror" class="mr-2"> Mirror Image
        </label>
    </div>
</div>
<script>
    const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 vTexCoord;
            void main() {
                gl_Position = vec4(a_position, 0, 1);
                vTexCoord = vec2(a_texCoord.x, 1.0 - a_texCoord.y);
            }
        `;

    const fragmentShaderSource = `
            precision mediump float;
            uniform sampler2D tex;
            uniform int colour_blindness_type;
            uniform float colour_blindness_correction;
            varying vec2 vTexCoord;

            void main(void) {
                vec4 color = texture2D(tex, vTexCoord);

                // RGB to LMS conversion
                mat3 RGB_to_LMS = mat3(
                    0.31399022, 0.63951294, 0.04649755,
                    0.15537241, 0.75789446, 0.08670142,
                    0.01775239, 0.10944209, 0.87256922
                );

                // LMS to RGB conversion
                mat3 LMS_to_RGB = mat3(
                    5.47221206, -4.6419601, 0.16963708,
                    -1.1252419, 2.29317094, -0.1678952,
                    0.02980165, -0.19318073, 1.16364789
                );

                // Transform the color from RGB to LMS
                vec3 LMS = RGB_to_LMS * color.rgb;

                vec3 simulated_LMS;
                if (colour_blindness_type == 0) {
                    // Protanopia simulation (L cone deficiency)
                    // Based on Brettel et al. (1997) and Viénot et al. (1999)
                    // Modified to prevent extreme values that cause blockiness
                    simulated_LMS = vec3(
                        0.0 * LMS.r + 1.05118294 * LMS.g - 0.05116099 * LMS.b,
                        LMS.g,
                        LMS.b
                    );
                } else if (colour_blindness_type == 1) {
                    // Deuteranopia simulation (M cone deficiency)
                    // Based on Brettel et al. (1997) and Viénot et al. (1999)
                    // Modified to prevent extreme values that cause blockiness
                    simulated_LMS = vec3(
                        LMS.r,
                        0.494207 * LMS.r + 0.503174 * LMS.g + 0.000019 * LMS.b,
                        LMS.b
                    );
                } else if (colour_blindness_type == 2) {
                    // Tritanopia simulation (S cone deficiency)
                    // Based on Brettel et al. (1997) and Viénot et al. (1999)
                    simulated_LMS = vec3(
                        LMS.r,
                        LMS.g,
                        -0.01224 * LMS.r + 0.07203 * LMS.g
                    );
                } else {
                    simulated_LMS = LMS;
                }

                // Adjust the simulation with the correction factor
                simulated_LMS = mix(LMS, simulated_LMS, colour_blindness_correction);

                // Transform the color back from LMS to RGB
                vec3 simulated_RGB = LMS_to_RGB * simulated_LMS;

                // Clamp values to prevent artifacts
                simulated_RGB = clamp(simulated_RGB, 0.0, 1.0);

                gl_FragColor = vec4(simulated_RGB, color.a);
            }
        `;

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,
        1, -1,
        -1, 1,
        -1, 1,
        1, -1,
        1, 1,
    ]), gl.STATIC_DRAW);

    const texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0, 0,
        1, 0,
        0, 1,
        0, 1,
        1, 0,
        1, 1,
    ]), gl.STATIC_DRAW);

    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

    let video = document.createElement('video');
    video.autoplay = true;
    let currentStream = null;

    async function setupVideo(deviceId) {
        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
        }

        // Get the selected resolution
        const resolutionValue = document.getElementById('resolution').value;
        const [width, height] = resolutionValue.split('x').map(Number);

        // First try with exact constraints
        let constraints = {
            video: {
                deviceId: deviceId ? {exact: deviceId} : undefined,
                width: { exact: width },
                height: { exact: height }
            }
        };

        try {
            try {
                // First try with exact constraints
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            } catch (exactError) {
                console.warn("Could not get exact resolution, falling back to ideal constraints:", exactError.message);

                // Fall back to ideal constraints if exact fails
                constraints.video.width = { ideal: width };
                constraints.video.height = { ideal: height };
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            }

            video.srcObject = currentStream;

            // Update canvas size to match video dimensions
            const videoTrack = currentStream.getVideoTracks()[0];
            const settings = videoTrack.getSettings();
            const videoAspectRatio = settings.width / settings.height;
            const requestedAspectRatio = width / height;

            console.log(`Requested resolution: ${width}x${height}, aspect ratio: ${requestedAspectRatio.toFixed(3)}`);
            console.log(`Actual resolution: ${settings.width}x${settings.height}, aspect ratio: ${videoAspectRatio.toFixed(3)}`);

            if (Math.abs(videoAspectRatio - requestedAspectRatio) > 0.01) {
                console.warn(`Aspect ratio mismatch: requested ${requestedAspectRatio.toFixed(3)}, got ${videoAspectRatio.toFixed(3)}`);
            }

            // Set the internal canvas dimensions to match video exactly
            const canvas = document.getElementById('canvas');
            canvas.width = settings.width;
            canvas.height = settings.height;

            // Adjust the displayed canvas size to maintain aspect ratio
            setTimeout(adjustCanvasSize, 0);

            return video;
        } catch (error) {
            console.error("Error accessing webcam:", error);
            alert("Error accessing webcam with the selected resolution. Please try a different resolution.");
            return null;
        }
    }

    async function getCameras() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        const cameraSelect = document.getElementById('camera');
        cameraSelect.innerHTML = '';
        videoDevices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Camera ${cameraSelect.length + 1}`;
            cameraSelect.appendChild(option);
        });
    }

    function updateTexture() {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    }

    // Function to create or update section labels
    function updateSectionLabels(isShowAll, layout, sectionInfo) {
        // Remove any existing labels
        document.querySelectorAll('.section-label').forEach(label => label.remove());

        if (!isShowAll) return;

        const container = document.getElementById('canvas-container');
        const canvas = document.getElementById('canvas');
        const rect = canvas.getBoundingClientRect();

        const labels = [
            { id: 'protanopia-label', text: 'Protanopia (Red-Green Color Blindness)' },
            { id: 'deuteranopia-label', text: 'Deuteranopia (Red-Green Color Blindness)' },
            { id: 'tritanopia-label', text: 'Tritanopia (Blue-Yellow Color Blindness)' }
        ];

        // If we don't have section info, use default positioning
        if (!sectionInfo) {
            labels.forEach((label, index) => {
                const elem = document.createElement('div');
                elem.id = label.id;
                elem.className = 'section-label';
                elem.textContent = label.text;
                container.appendChild(elem);

                // Position the label based on layout
                if (layout === 'horizontal') {
                    const sectionWidth = rect.width / 3;
                    elem.style.left = `${rect.left + (sectionWidth * index) + 10}px`;
                    elem.style.top = `${rect.top + 10}px`;
                } else { // vertical
                    const sectionHeight = rect.height / 3;
                    elem.style.left = `${rect.left + 10}px`;
                    elem.style.top = `${rect.top + (sectionHeight * (2 - index)) + 10}px`; // Reverse order (0 at top)
                }
            });
            return;
        }

        // Use the section info for precise positioning
        labels.forEach((label, index) => {
            const elem = document.createElement('div');
            elem.id = label.id;
            elem.className = 'section-label';
            elem.textContent = label.text;
            container.appendChild(elem);

            // Get the position info for this section
            const section = sectionInfo[index];

            // Convert WebGL viewport coordinates to screen coordinates
            const canvasWidth = rect.width;
            const canvasHeight = rect.height;

            // Calculate the position of the label
            let labelX, labelY;

            if (layout === 'horizontal') {
                // For horizontal layout, center the label in each section
                labelX = rect.left + (section.x / canvas.width * canvasWidth) + (section.width / canvas.width * canvasWidth / 2) - (elem.offsetWidth / 2);
                labelY = rect.top + 10; // Keep at the top
            } else { // vertical
                // For vertical layout, position at the top-left of each section
                labelX = rect.left + (section.x / canvas.width * canvasWidth) + 10;
                labelY = rect.top + (section.y / canvas.height * canvasHeight) + 10;
            }

            // Apply the position
            elem.style.left = `${labelX}px`;
            elem.style.top = `${labelY}px`;
        });
    }

    function drawScene() {
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(program);

        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.enableVertexAttribArray(texCoordLocation);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

        updateTexture();

        const type = parseInt(document.getElementById('type').value);
        const correction = parseFloat(document.getElementById('correction').value);
        const mirror = document.getElementById('mirror').checked;
        const isShowAll = type === 3;

        gl.uniform1i(gl.getUniformLocation(program, 'tex'), 0);
        gl.uniform1f(gl.getUniformLocation(program, 'colour_blindness_correction'), correction);

        // Set up position buffer based on mirror setting
        const positionData = mirror ?
            new Float32Array([
                1, -1,
                -1, -1,
                1, 1,
                1, 1,
                -1, -1,
                -1, 1,
            ]) :
            new Float32Array([
                -1, -1,
                1, -1,
                -1, 1,
                -1, 1,
                1, -1,
                1, 1,
            ]);

        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positionData, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        if (isShowAll) {
            // Show all three types side by side
            const canvasWidth = gl.canvas.width;
            const canvasHeight = gl.canvas.height;

            // Get the video aspect ratio from the video track settings
            let videoAspectRatio = 16/9; // Default fallback
            if (currentStream) {
                const videoTrack = currentStream.getVideoTracks()[0];
                if (videoTrack) {
                    const settings = videoTrack.getSettings();
                    videoAspectRatio = settings.width / settings.height;
                    console.log(`Using video aspect ratio for sections: ${videoAspectRatio.toFixed(5)}`);
                }
            }

            // Calculate the width of each section based on the aspect ratio and orientation
            const canvasAspectRatio = canvasWidth / canvasHeight;
            let sectionWidth, sectionHeight;
            let layout;

            // Array to store section positions for label positioning
            const sectionPositions = [];

            // Determine layout based on orientation, aspect ratio, and screen size
            const isLandscape = window.matchMedia("(orientation: landscape)").matches;
            const isVerySmallScreen = Math.min(canvasWidth, canvasHeight) < 400;

            // On very small screens, choose the layout that maximizes video size
            // For wider screens, use horizontal layout; for taller screens, use vertical layout
            if ((isLandscape && canvasAspectRatio >= 1.5) ||
                (isVerySmallScreen && canvasWidth > canvasHeight)) {
                // Landscape orientation with sufficient width: divide horizontally
                layout = 'horizontal';

                // Calculate section dimensions that preserve video aspect ratio
                // Each section should have the same aspect ratio as the video
                const totalWidth = canvasWidth;
                const availableHeight = canvasHeight;

                // Use more of the available width (up to 99% on very small screens)
                // Use smaller spacing on small screens
                const isSmallScreen = totalWidth < 600;
                const isVerySmallScreen = totalWidth < 400;

                // Adjust spacing based on screen size: 0.5% for very small, 1% for small, 2% for normal
                const spacingPercentage = isVerySmallScreen ? 0.005 : (isSmallScreen ? 0.01 : 0.02);
                const sectionSpacing = Math.max(1, Math.floor(totalWidth * spacingPercentage)); // Ensure at least 1px spacing

                // For very small screens, use even more of the available space
                const usableWidth = totalWidth - (sectionSpacing * 2); // Account for 2 spaces between 3 sections
                const individualWidth = Math.floor(usableWidth / 3);

                // Calculate the width of each section
                sectionWidth = individualWidth;

                // Calculate the height that maintains the video aspect ratio
                sectionHeight = Math.floor(sectionWidth / videoAspectRatio);

                // If calculated height is too tall, adjust both dimensions
                if (sectionHeight > availableHeight) {
                    sectionHeight = availableHeight;
                    sectionWidth = Math.floor(sectionHeight * videoAspectRatio);
                }

                // Calculate vertical centering offset
                const yOffset = Math.floor((availableHeight - sectionHeight) / 2);

                console.log(`Horizontal layout: section size ${sectionWidth}x${sectionHeight}, aspect ratio: ${(sectionWidth/sectionHeight).toFixed(5)}`);

                // Draw Protanopia (left section)
                const leftX = sectionSpacing;
                gl.viewport(leftX, yOffset, sectionWidth, sectionHeight);
                gl.uniform1i(gl.getUniformLocation(program, 'colour_blindness_type'), 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                sectionPositions.push({ x: leftX, y: yOffset, width: sectionWidth, height: sectionHeight });

                // Draw Deuteranopia (middle section)
                const middleX = leftX + sectionWidth + sectionSpacing;
                gl.viewport(middleX, yOffset, sectionWidth, sectionHeight);
                gl.uniform1i(gl.getUniformLocation(program, 'colour_blindness_type'), 1);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                sectionPositions.push({ x: middleX, y: yOffset, width: sectionWidth, height: sectionHeight });

                // Draw Tritanopia (right section)
                const rightX = middleX + sectionWidth + sectionSpacing;
                gl.viewport(rightX, yOffset, sectionWidth, sectionHeight);
                gl.uniform1i(gl.getUniformLocation(program, 'colour_blindness_type'), 2);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                sectionPositions.push({ x: rightX, y: yOffset, width: sectionWidth, height: sectionHeight });
            } else {
                // Narrow screen: stack vertically
                layout = 'vertical';

                // Calculate section dimensions that preserve video aspect ratio
                const availableWidth = canvasWidth;
                const totalHeight = canvasHeight;

                // Use more of the available height (up to 99% on very small screens)
                // Use smaller spacing on small screens
                const isSmallScreen = totalHeight < 600;
                const isVerySmallScreen = totalHeight < 400;

                // Adjust spacing based on screen size: 0.5% for very small, 1% for small, 2% for normal
                const spacingPercentage = isVerySmallScreen ? 0.005 : (isSmallScreen ? 0.01 : 0.02);
                const sectionSpacing = Math.max(1, Math.floor(totalHeight * spacingPercentage)); // Ensure at least 1px spacing

                // For very small screens, use even more of the available space
                const usableHeight = totalHeight - (sectionSpacing * 2); // Account for 2 spaces between 3 sections
                const individualHeight = Math.floor(usableHeight / 3);

                // Calculate the height of each section
                sectionHeight = individualHeight;

                // Calculate the width that maintains the video aspect ratio
                sectionWidth = Math.floor(sectionHeight * videoAspectRatio);

                // If calculated width is too wide, adjust both dimensions
                if (sectionWidth > availableWidth) {
                    sectionWidth = availableWidth;
                    sectionHeight = Math.floor(sectionWidth / videoAspectRatio);
                }

                // Calculate horizontal centering offset
                const xOffset = Math.floor((availableWidth - sectionWidth) / 2);

                console.log(`Vertical layout: section size ${sectionWidth}x${sectionHeight}, aspect ratio: ${(sectionWidth/sectionHeight).toFixed(5)}`);

                // Draw Protanopia (top section)
                const topY = totalHeight - sectionHeight - sectionSpacing;
                gl.viewport(xOffset, topY, sectionWidth, sectionHeight);
                gl.uniform1i(gl.getUniformLocation(program, 'colour_blindness_type'), 0);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                sectionPositions.push({ x: xOffset, y: topY, width: sectionWidth, height: sectionHeight });

                // Draw Deuteranopia (middle section)
                const middleY = topY - sectionHeight - sectionSpacing;
                gl.viewport(xOffset, middleY, sectionWidth, sectionHeight);
                gl.uniform1i(gl.getUniformLocation(program, 'colour_blindness_type'), 1);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                sectionPositions.push({ x: xOffset, y: middleY, width: sectionWidth, height: sectionHeight });

                // Draw Tritanopia (bottom section)
                const bottomY = middleY - sectionHeight - sectionSpacing;
                gl.viewport(xOffset, bottomY, sectionWidth, sectionHeight);
                gl.uniform1i(gl.getUniformLocation(program, 'colour_blindness_type'), 2);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                sectionPositions.push({ x: xOffset, y: bottomY, width: sectionWidth, height: sectionHeight });
            }

            // Update section labels with precise positioning information
            updateSectionLabels(true, layout, sectionPositions);
        } else {
            // Show single type (full screen)
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.uniform1i(gl.getUniformLocation(program, 'colour_blindness_type'), type);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Remove any section labels
            updateSectionLabels(false);
        }

        requestAnimationFrame(drawScene);
    }

    document.getElementById('camera').addEventListener('change', async (event) => {
        await setupVideo(event.target.value);
        video.play();
    });

    document.getElementById('resolution').addEventListener('change', async () => {
        const cameraSelect = document.getElementById('camera');
        await setupVideo(cameraSelect.value);
        video.play();
    });

    // Add event listener for type dropdown to update section labels
    document.getElementById('type').addEventListener('change', () => {
        // When type changes, update the section labels
        const type = parseInt(document.getElementById('type').value);

        if (type === 3) {
            // Use the same layout logic as in adjustCanvasSize
            const container = document.getElementById('canvas-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const containerAspectRatio = containerWidth / containerHeight;
            const isLandscape = window.matchMedia("(orientation: landscape)").matches;
            const isVerySmallScreen = Math.min(containerWidth, containerHeight) < 400;

            // Use the same layout determination logic as in drawScene
            const layout = (isLandscape && containerAspectRatio >= 1.5) ||
                          (isVerySmallScreen && containerWidth > containerHeight) ? 'horizontal' : 'vertical';

            // Let drawScene handle the actual label positioning on the next frame
            // This will trigger a redraw which will position the labels correctly
            updateSectionLabels(true, layout, null);
        } else {
            updateSectionLabels(false);
        }
    });

    video.addEventListener('canplay', () => {
        video.play();
        requestAnimationFrame(drawScene);
    });

    // Function to adjust canvas size and maintain aspect ratio
    function adjustCanvasSize() {
        if (!currentStream) return;

        const videoTrack = currentStream.getVideoTracks()[0];
        if (!videoTrack) return;

        const settings = videoTrack.getSettings();
        // Get the exact video dimensions and aspect ratio
        const videoWidth = settings.width;
        const videoHeight = settings.height;
        const videoAspectRatio = videoWidth / videoHeight;

        console.log(`Adjusting canvas size to match video aspect ratio: ${videoAspectRatio.toFixed(5)}`);
        console.log(`Video dimensions: ${videoWidth}x${videoHeight}`);

        const canvas = document.getElementById('canvas');
        const container = document.getElementById('canvas-container');
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const containerAspectRatio = containerWidth / containerHeight;

        // Calculate dimensions that preserve aspect ratio exactly
        let canvasWidth, canvasHeight;

        if (containerAspectRatio > videoAspectRatio) {
            // Container is wider than video
            canvasHeight = Math.min(containerHeight, window.innerHeight);
            // Calculate width to exactly match the video aspect ratio
            canvasWidth = Math.round(canvasHeight * videoAspectRatio);
        } else {
            // Container is taller than video
            canvasWidth = Math.min(containerWidth, window.innerWidth);
            // Calculate height to exactly match the video aspect ratio
            canvasHeight = Math.round(canvasWidth / videoAspectRatio);
        }

        console.log(`Calculated canvas dimensions: ${canvasWidth}x${canvasHeight}, aspect ratio: ${(canvasWidth/canvasHeight).toFixed(5)}`);

        // Apply the calculated dimensions
        canvas.style.width = `${canvasWidth}px`;
        canvas.style.height = `${canvasHeight}px`;

        // Center the canvas in the container
        canvas.style.position = 'absolute';
        canvas.style.left = '50%';
        canvas.style.top = '50%';
        canvas.style.transform = 'translate(-50%, -50%)';

        // Update section labels if in "Show All" mode
        const type = parseInt(document.getElementById('type').value);
        if (type === 3) {
            // Determine layout based on orientation and aspect ratio
            const isLandscape = window.matchMedia("(orientation: landscape)").matches;
            const layout = isLandscape && containerAspectRatio >= 1.5 ? 'horizontal' : 'vertical';
            // Let drawScene handle the actual label positioning on the next frame
            updateSectionLabels(true, layout, null);
        }
    }

    // Handle window resize to maintain canvas aspect ratio and update labels
    window.addEventListener('resize', adjustCanvasSize);

    // Handle orientation change explicitly
    window.addEventListener('orientationchange', () => {
        // Small delay to allow the browser to complete the orientation change
        setTimeout(adjustCanvasSize, 100);
    });

    getCameras();
    setupVideo();
</script>
</body>
</html>
