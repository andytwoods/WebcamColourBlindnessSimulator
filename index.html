<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam Colour Blindness Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; }
        #canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            position: relative;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }
        .canvas-wrapper {
            display: flex;
            justify-content: space-between;
            width: 100%; /* Ensure the container fills the available width */
        }

        .canvas-wrapper canvas {
            flex: 1; /* Equal width for each canvas */
        }
        canvas {
            //width: 100%;
            //height: 100%;
        }
    </style>
</head>
<body class="bg-gray-900">
<div id="canvas-container">
    <div class="controls">
        <label for="camera" class="block text-white mb-2">Camera:</label>
        <select id="camera" class="block mb-4 p-2 rounded"></select>
        <label class="block text-white mb-2">
            <input type="checkbox" id="mirror" class="mr-2"> Mirror Image
        </label>
    </div>
    <div id="multiple-canvases" class="canvas-wrapper">
        <canvas id="canvas1" class="h-full w-1/3"></canvas>
        <canvas id="canvas2" class="h-full w-1/3"></canvas>
        <canvas id="canvas3" class="h-full w-1/3"></canvas>
    </div>
</div>
<script>
    const vertexShaderSource = `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 vTexCoord;
        void main() {
            gl_Position = vec4(a_position, 0, 1);
            vTexCoord = vec2(a_texCoord.x, 1.0 - a_texCoord.y);
        }
    `;

    const fragmentShaderSource = `
        precision mediump float;
        uniform sampler2D tex;
        uniform int colour_blindness_type;
        uniform float colour_blindness_correction;
        varying vec2 vTexCoord;

        void main(void) {
            vec4 color = texture2D(tex, vTexCoord);

            // RGB to LMS conversion
            mat3 RGB_to_LMS = mat3(
                0.31399022, 0.63951294, 0.04649755,
                0.15537241, 0.75789446, 0.08670142,
                0.01775239, 0.10944209, 0.87256922
            );

            // LMS to RGB conversion
            mat3 LMS_to_RGB = mat3(
                5.47221206, -4.6419601, 0.16963708,
                -1.1252419, 2.29317094, -0.1678952,
                0.02980165, -0.19318073, 1.16364789
            );

            // Transform the color from RGB to LMS
            vec3 LMS = RGB_to_LMS * color.rgb;

            vec3 simulated_LMS;
            if (colour_blindness_type == 0) {
                // Protanopia simulation
                simulated_LMS = vec3(
                    0.0,
                    LMS.g,
                    LMS.b
                );
            } else if (colour_blindness_type == 1) {
                // Deuteranopia simulation
                simulated_LMS = vec3(
                    LMS.r,
                    0.0,
                    LMS.b
                );
            } else if (colour_blindness_type == 2) {
                // Tritanopia simulation
                simulated_LMS = vec3(
                    LMS.r,
                    LMS.g,
                    0.0
                );
            } else {
                simulated_LMS = LMS;
            }

            // Adjust the simulation with the correction factor
            simulated_LMS = mix(LMS, simulated_LMS, colour_blindness_correction);

            // Transform the color back from LMS to RGB
            vec3 simulated_RGB = LMS_to_RGB * simulated_LMS;

            gl_FragColor = vec4(simulated_RGB, color.a);
        }
    `;

    const canvas1 = document.getElementById('canvas1');
    const canvas2 = document.getElementById('canvas2');
    const canvas3 = document.getElementById('canvas3');
    const gl1 = canvas1.getContext('webgl');
    const gl2 = canvas2.getContext('webgl');
    const gl3 = canvas3.getContext('webgl');

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }

    const vertexShader1 = createShader(gl1, gl1.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader1 = createShader(gl1, gl1.FRAGMENT_SHADER, fragmentShaderSource);
    const program1 = createProgram(gl1, vertexShader1, fragmentShader1);

    const vertexShader2 = createShader(gl2, gl2.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader2 = createShader(gl2, gl2.FRAGMENT_SHADER, fragmentShaderSource);
    const program2 = createProgram(gl2, vertexShader2, fragmentShader2);

    const vertexShader3 = createShader(gl3, gl3.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader3 = createShader(gl3, gl3.FRAGMENT_SHADER, fragmentShaderSource);
    const program3 = createProgram(gl3, vertexShader3, fragmentShader3);

    function setupBuffers(gl, program) {
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,
            1, -1,
            -1,  1,
            -1,  1,
            1, -1,
            1,  1,
        ]), gl.STATIC_DRAW);

        const texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            0, 0,
            1, 0,
            0, 1,
            0, 1,
            1, 0,
            1, 1,
        ]), gl.STATIC_DRAW);

        return { positionLocation, texCoordLocation, positionBuffer, texCoordBuffer };
    }

    const buffers1 = setupBuffers(gl1, program1);
    const buffers2 = setupBuffers(gl2, program2);
    const buffers3 = setupBuffers(gl3, program3);

    let video = document.createElement('video');
    video.autoplay = true;
    video.style.objectFit = 'cover';
    let currentStream = null;

    async function setupVideo(deviceId) {
        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
        }
        const constraints = {
            video: { deviceId: deviceId ? { exact: deviceId } : undefined }
        };
        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = currentStream;
        return video;
    }

    async function getCameras() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        const cameraSelect = document.getElementById('camera');
        cameraSelect.innerHTML = '';
        videoDevices.forEach(device => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.text = device.label || `Camera ${cameraSelect.length + 1}`;
            cameraSelect.appendChild(option);
        });
    }

    function updateTexture(gl) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        return texture;
    }

    function drawScene(gl, program, buffers, type, mirror) {
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(program);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.positionBuffer);
        gl.enableVertexAttribArray(buffers.positionLocation);
        gl.vertexAttribPointer(buffers.positionLocation, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.texCoordBuffer);
        gl.enableVertexAttribArray(buffers.texCoordLocation);
        gl.vertexAttribPointer(buffers.texCoordLocation, 2, gl.FLOAT, false, 0, 0);

        const texture = updateTexture(gl);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniform1i(gl.getUniformLocation(program, 'tex'), 0);
        gl.uniform1i(gl.getUniformLocation(program, 'colour_blindness_type'), type);
        gl.uniform1f(gl.getUniformLocation(program, 'colour_blindness_correction'), 1.0);

        if (mirror) {
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                1, -1,
                -1, -1,
                1, 1,
                1, 1,
                -1, -1,
                -1, 1,
            ]), gl.STATIC_DRAW);
        } else {
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,
                1, -1,
                -1, 1,
                -1, 1,
                1, -1,
                1, 1,
            ]), gl.STATIC_DRAW);
        }

        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    function resizeCanvases() {
        const canvases = [canvas1, canvas2, canvas3];
        canvases.forEach(canvas => {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        });
    }

    window.addEventListener('resize', resizeCanvases);
    resizeCanvases();

    function render() {
        const mirror = document.getElementById('mirror').checked;

        drawScene(gl1, program1, buffers1, 0, mirror);
        drawScene(gl2, program2, buffers2, 1, mirror);
        drawScene(gl3, program3, buffers3, 2, mirror);

        requestAnimationFrame(render);
    }

    document.getElementById('camera').addEventListener('change', async (event) => {
        await setupVideo(event.target.value);
        video.play();
    });

    video.addEventListener('canplay', () => {
        video.play();
        requestAnimationFrame(render);
    });

    getCameras();
    setupVideo();
</script>
</body>
</html>
